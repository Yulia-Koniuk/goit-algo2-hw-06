# goit-algo2-hw-06

**Завдання 1. Перевірка унікальності паролів за допомогою фільтра Блума**\
Створіть функцію для перевірки унікальності паролів за допомогою фільтра Блума. Ця функція має визначати, чи використовувався пароль раніше, без необхідності зберігати самі паролі.

_Результати виконання:_\
Пароль 'password123' - вже використаний.\
Пароль 'newpassword' - унікальний.\
Пароль 'admin123' - вже використаний.\
Пароль 'guest' - унікальний.\
Пароль '' - некоректний пароль.\
Пароль 'None' - некоректний пароль.

**Висновок: алгоритм працює коректно, перевіряє унікальність паролів без зберігання самих рядків, дозволяючи визначати, які паролі вже використовувалися, а які є новими. Результати показують, які паролі унікальні, які вже використані, а також демонструють коректну обробку порожніх або некоректних значень.**\
\
\
\
\
**Завдання 2. Порівняння продуктивності HyperLogLog із точним підрахунком унікальних елементів**\
Створіть скрипт для порівняння точного підрахунку унікальних елементів та підрахунку за допомогою HyperLogLog.

_Результати виконання:_\
--- Порівняння продуктивності за допомогою реального лог-файлу ---\
Завантажено 61416 рядків (IP).\
Результати порівняння:\
Метод                    - Унікальні елементи  - Час виконання (сек.) - Пам’ять (байт)\
Точний підрахунок        - 31                  - 0.001028             - 3928\
HyperLogLog              - 31.0                - 0.021900             - 131128

--- Перевірка адаптованості до великих наборів ---\
Метод                    - Унікальні елементи  - Час виконання (сек.) - Пам’ять (байт)
Точний підрахунок        - 1000000             - 0.127200             - 33554648
HyperLogLog              - 1000207.8           - 0.493102             - 8388664


_Порівняння:_\
**--- Порівняння продуктивності за допомогою реального лог-файлу ---**\
_Унікальні елементи:_\
Set (exact_unique_count) знайшов 31 унікальний IP - це реальна точна кількість.\
HyperLogLog дав 31.0, що дуже близько, тобто похибка практично нульова, оскільки дані невеликі і p=14 достатньо для точної оцінки.

_Час виконання:_\
Set працює майже миттєво (0.001 с), HyperLogLog трохи повільніше (0.028 с) через обчислення хешів та оновлення регістрів.

_Пам’ять_:
Set займає лише 3928 байт для 31 елемента — дуже мало, бо даних небагато.\
HyperLogLog — 131128 байт, бо ми виділяємо 2^14 = 16384 регістрів (по 8 байт на int у Python), навіть якщо даних мало. HyperLogLog має фіксований розмір пам’яті, який не залежить від кількості елементів.

**--- Порівняння продуктивності за допомогою великого набору даних ---**\
_Унікальні елементи:_\
Set рахує точно - 1 000 000, HyperLogLog оцінює ~1 000 208. Це невелика похибка (~0.02%), яка для HLL вважається гарним результатом.

_Час виконання:_\
Set - дуже швидко (0.11 с) для 1 млн елементів, але пам’ять росте лінійно.\ 
HyperLogLog повільніше (~0.5 с), бо треба обчислювати хеші і оновлювати 2^20 регістрів, але час усе ще прийнятний.

_Пам’ять_:
Set - 33,5 МБ, HyperLogLog - 8,3 МБ. Тобто HLL значно економить пам’ять при обробці великих наборів, що є основною перевагою алгоритму.

**Висновок: Алгоритми працюють коректно і дозволяють визначати унікальні елементи в наборі даних.\Для малих і середніх наборів точний підрахунок через set показує швидкий час виконання і точні результати, але споживає більше пам’яті, особливо при великій кількості елементів. HyperLogLog для малих наборів менш ефективний по пам’яті і трохи повільніший, оскільки наклад обчислень відносно великий.\Для великих наборів даних HyperLogLog дає дуже точну оцінку кардинальності, займає значно менше пам’яті, хоча час виконання зростає порівняно з set. \Таким чином, точний підрахунок оптимальний для невеликих даних, а HyperLogLog ß для великих наборів як ефективний компроміс між пам’яттю та часом обчислень.**\